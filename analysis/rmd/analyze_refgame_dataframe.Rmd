---
title: "analyze_refgame_dataframe"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggthemes)
library(lme4)
library(lmerTest)
library(brms)
#library(Rmisc)
library(tidyboot)
```

## Import group data

```{r}
d <- read_csv('../../results/graphical_conventions.csv')  %>% select(-png)
d.bis.drawDuration <- read_csv('../../results/graphical_conventions_bis_score_drawDuration.csv')  %>% select(-X1)
d.bis.numStrokes <- read_csv('../../results/graphical_conventions_bis_score_numStrokes.csv') %>% select(-X1)
```

## Generate histograms for numCurvesPerSketch and numStrokes 

```{r}
d %>% 
  group_by(numCurvesPerSketch) %>% ggplot(aes(x = numCurvesPerSketch)) + geom_histogram()
```

```{r}
d %>% 
  group_by(numStrokes) %>% ggplot(aes(x = numStrokes)) + geom_histogram()
```

## Behavioral Results: BIS analysis (on drawDuration)

```{r}
# generate "baseline" bis dataframe that computes pre-phase BIS, grouped by condition and gameID
bbis <-d.bis.drawDuration %>%
      filter(repetition==0) %>%
      group_by(condition,gameID) %>%
      summarize(bis_score = mean(bis_score))

# add this "baseline" bis to each row of original bis dataframe
d.bis.drawDuration <- inner_join(d.bis.drawDuration, bbis, by = c('condition','gameID'), suffix = c("","_baseline")) %>%
                      mutate(bis_score_relative = bis_score - bis_score_baseline)
```

```{r}
d.bootstrap <- d.bis.drawDuration %>% group_by(condition, repetition) %>% tidyboot_mean(column=bis_score_relative)

d.bootstrap %>%
  ggplot(aes(x=repetition,y=empirical_stat, color=condition, fill=condition)) + 
    geom_ribbon(aes(ymin=ci_lower, ymax = ci_upper), alpha =.25, color=NA,
                data = d.bootstrap %>% filter(condition == 'repeated')) + # position = dodge, 
    geom_line()+#data = d.bootstrap %>% filter(condition == 'repeated')) + 
    geom_errorbar(aes(ymin=ci_lower, ymax = ci_upper), width = 0,
                  data = d.bootstrap %>% filter(condition == 'control')) + 
    geom_point(size = 2) + 
    scale_x_continuous(breaks = round(seq(min(d.bootstrap$repetition), max(d.bootstrap$repetition), by =1),1)) + 
    ylab("normalized efficiency") +
    theme_few() +
    ylim(-0.5,2.5) +
    scale_color_manual(values=c("#cc0000", "#0066cc")) + 
    scale_fill_manual(values=c("#cc0000", "#0066cc")) + 
    theme(legend.position = c(0.8, 0.2), text = element_text(size=18)) 
ggsave('../../writing/cogsci19/figures/bis_score.pdf', width=14, height = 14, units='cm')

```

## Mixed-effects model for BIS (on drawDuration)

```{r}
# preferred model definition for interaction between repetition and condition for bis -- has right syntax but doesn't converge
# interaction_lmm <- lmer(bis_score ~ phase * condition + (1 + phase*condition | target) + (1 + phase*condition | gameID)

# alternative model definition (removing game-wise random effects for phase*condition interaction)
interaction_lmm <- lmer(bis_score ~ phase * condition + (1 + phase*condition | target), 
                        data = d.bis.drawDuration %>%
                                filter(repetition == 0 | repetition == 7) %>% 
                                mutate(phase = ifelse(repetition == 0, 'pre', 'post'))) 

print(summary(interaction_lmm))
#print(coef(summary(interaction_lmm)))
```

## Within-interaction convergence

```{r}
M_mat = read_csv('../ipynb/rxdh/M.csv') %>%
  filter(condition == 'repeated') %>%
  select(gameID, target, repetition, feature_ind) %>%
  mutate(feature_ind = feature_ind + 1) %>% # Have to correct for R 1-indexing...
  arrange(gameID, target, repetition) 
F_mat = as.matrix(read_delim('../ipynb/rxdh/F.txt', delim=',', col_names=F))
colnames(F_mat) <- NULL
```

```{r}
# note: cor expects featurs to be in columns so we transpose
getCorrMatrix = function(df) {
  feats <- F_mat[df$feature_ind,]
  return(cor(t(feats)))
}

flattenCorrMatrix <- function(cormat) {
  ut <- upper.tri(cormat)
  data.frame(
    rep1 = seq(0,7)[row(cormat)[ut]],
    rep2 = seq(0,7)[col(cormat)[ut]],
    cor  = cormat[ut]
    )
}

compute_within_similarity <- function(M_mat, nboot = 1) {
  return(M_mat %>%
    complete(nesting(gameID, target), repetition) %>%   # Fill in NAs for missing repetitions
    group_by(gameID, target) %>%
    do(flattenCorrMatrix(getCorrMatrix(.))) %>%
    group_by(rep1, rep2) %>%
    tidyboot_mean(col = cor, na.rm=T, nboot = nboot) %>%
    filter(rep2 == rep1+1) %>%
    unite(`rep diff`, rep1, rep2, sep = '->'))
}

within_similarity <- compute_within_similarity(M_mat, nboot = 1)
within_similarity
```

```{r}
## TODO: run a bunch of times with permuted
permuted <- M_mat %>%
  complete(nesting(gameID, target), repetition) %>%   # Fill in NAs for missing repetitions
  group_by(gameID, target) %>%
  do(flattenCorrMatrix(getCorrMatrix(.))) %>%
  group_by(rep1, rep2) %>%
  tidyboot_mean(col = cor, na.rm = T) %>%
  filter(rep2 == rep1+1) %>%
  unite(`rep diff`, rep1, rep2, sep = '->')

```

```{r}
ggplot(within_similarity, aes(x = `rep diff`, y = empirical_stat,
                              group=1)) +
  geom_line() +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.5) +
  theme_few()
```

## Between-interaction divergence 

```{r}


```

## Temporal structure 

```{r}


```
