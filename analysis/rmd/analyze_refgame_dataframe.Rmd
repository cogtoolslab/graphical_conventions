---
title: "analyze_refgame_dataframe"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggthemes)
library(lme4)
library(lmerTest)
library(brms)
#library(Rmisc)
library(tidyboot)
```

## Import group data

```{r}
d <- read_csv('../../results/graphical_conventions.csv')  %>% select(-png)
d.bis.drawDuration <- read_csv('../../results/graphical_conventions_bis_score_drawDuration.csv')  %>% select(-X1)
d.bis.numStrokes <- read_csv('../../results/graphical_conventions_bis_score_numStrokes.csv') %>% select(-X1)
```

```{r}
d
```

## Generate histograms for numCurvesPerSketch and numStrokes 

```{r}
d %>% 
  group_by(numCurvesPerSketch) %>% ggplot(aes(x = numCurvesPerSketch)) + geom_histogram()
```

```{r}
d %>% 
  group_by(numStrokes) %>% ggplot(aes(x = numStrokes)) + geom_histogram()
```

## Behavioral Results: BIS analysis (on drawDuration)

```{r}
# generate "baseline" bis dataframe that computes pre-phase BIS, grouped by condition and gameID
bbis <-d.bis.drawDuration %>%
      filter(repetition==0) %>%
      group_by(condition,gameID) %>%
      summarize(bis_score = mean(bis_score))

# add this "baseline" bis to each row of original bis dataframe
d.bis.drawDuration <- inner_join(d.bis.drawDuration, bbis, by = c('condition','gameID'), suffix = c("","_baseline")) %>%
                      mutate(bis_score_relative = bis_score - bis_score_baseline) %>%
                      mutate(repetition_1 = repetition + 1)
```

```{r}
d.bootstrap <- d.bis.drawDuration %>% group_by(condition, repetition_1) %>% tidyboot_mean(column=bis_score_relative)

d.bootstrap %>%
  ggplot(aes(x=repetition_1,y=empirical_stat, color=condition, fill=condition)) + 
    geom_ribbon(aes(ymin=ci_lower, ymax = ci_upper), alpha =.25, color=NA,
                data = d.bootstrap %>% filter(condition == 'repeated')) + # position = dodge, 
    geom_line(size=1.5)+#data = d.bootstrap %>% filter(condition == 'repeated')) + 
    geom_errorbar(aes(ymin=ci_lower, ymax = ci_upper), width = 0, size = 1.5,
                  data = d.bootstrap %>% filter(condition == 'control')) + 
    # geom_point(size = 5) + 
    ylab("relative efficiency") +
    xlab("repetition") +
    theme_few() +
    scale_x_continuous(breaks = round(seq(min(d.bootstrap$repetition_1), max(d.bootstrap$repetition_1), by =1),1)) + 
    scale_y_continuous(breaks = seq(-0.5,2.5,0.5)) +
    scale_color_manual(values=c("#d07e93", "#163c4e")) + 
    scale_fill_manual(values=c("#d07e93", "#163c4e")) + 
    theme(legend.position = c(0.8, 0.2), text = element_text(size=18), element_line(size=1), element_rect(size=2, color="#00000"))
ggsave('../../results/plots/refgame_BIS_timeseries.pdf', width=14, height = 10, units='cm')

```

## Mixed-effects model for BIS (on drawDuration)

```{r}
# preferred model definition for interaction between repetition and condition for bis -- has right syntax but doesn't converge
# interaction_lmm <- lmer(bis_score ~ phase * condition + (1 + phase*condition | target) + (1 + phase*condition | gameID)

input <- d.bis.drawDuration %>%
         filter(repetition == 0 | repetition == 7) %>% 
         mutate(phase = ifelse(repetition == 0, 'pre', 'post'))

# alternative model definition (removing game-wise random effects for phase*condition interaction)
interaction_lmm <- lmer(bis_score ~ phase * condition + (1 + phase*condition | target), 
                        data = input)

print(summary(interaction_lmm))
#print(coef(summary(interaction_lmm)))
```

## Within-interaction convergence

Import pre-processed matrices from ipynb

```{r}
source('./helpers.R')
M_mat = read_csv('../../data/sketch_features/no_crop/METADATA_sketch.csv') %>%
  filter(condition == 'repeated') %>%
  select(gameID, target, repetition, feature_ind) %>%
  mutate(feature_ind = feature_ind + 1,
         repetition = as.numeric(repetition)) %>% # Have to correct for R 1-indexing...
  arrange(gameID, target, repetition) 
F_mat = as.matrix(read_delim('../../data/sketch_features/no_crop/FEATURES_FC6_sketch.txt', delim=',', col_names=F))
colnames(F_mat) <- NULL
```

Sanity check of whitening:

```{r}
cat('avg feat mean = ', mean(apply(F_mat, 2, mean)), '\n')
cat('avg feat sd = ', mean(apply(F_mat, 2, sd)))
```

Set up pipeline for within-game similarity

```{r}
F_by_game <- whitenF(M_mat, F_mat, 'by_game')
F_by_target <- whitenF(M_mat, F_mat, 'by_target')
```

```{r}
# lmer model
summary(lmer(cor ~ phase + (1 | gameID) + (1 | target),
     data = M_mat %>%
    group_by(gameID, target) %>%
    do(flatten_sim_matrix(get_sim_matrix(., F_by_game, method = 'euclidean'))) %>%
    filter(rep2 == rep1 + 1) %>% 
    filter(rep1 %in% c(0,6)) %>%
    mutate(phase = ifelse(rep1 == 0, 'pre', 'post')) %>%
    mutate(phase = factor(phase, levels = c('pre', 'post')))))
```

compute both true empirical & permuted output

```{r}
num_permutations <- 100
empirical.within <- compute_within_similarity(M_mat, 'empirical', nboot = 500)
baselines.within <- map_dfr(seq_len(num_permutations), ~M_mat %>%
  group_by(target, repetition) %>%
  mutate(gameID = sample(gameID)) %>% # shuffle within target-rep 
  ungroup() %>%
  compute_within_similarity(.x)) # this passes in the iteration number
```

Plot with permutations

```{r}
baselines.within %>%
  group_by(`rep diff`) %>%
  summarize(`ci_upper`=quantile(empirical_stat, probs=0.975),
            `ci_lower`=quantile(empirical_stat, probs=0.025),
            `empirical_stat`=quantile(empirical_stat, probs=0.5)) %>%
  mutate(sample_id = 'baseline') %>%
  rbind(empirical.within %>% select(-n, -mean)) %>%
  ggplot(aes(x = `rep diff`, y = empirical_stat, 
                               fill = sample_id == 'empirical', color = sample_id == 'empirical', group = sample_id)) +
    geom_line() +
    geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.5, color = NA ) + #data = empirical, 
    theme_few() +
    #ylim(0,.4) +
    guides(fill = F, color = F)
```

## Between-interaction divergence 

Look at curves broken out by target

```{r}
mod1 <- lmer(sim ~ repetition + (1 + repetition | target), data = M_mat %>%
  group_by(target, repetition) %>%
  do(flatten_sim_matrix_across(get_sim_matrix(., F_by_target, method = 'euclidean'))))
  # filter(repetition %in% c(0,7)) %>%
  # mutate(phase = ifelse(repetition == 0, 'pre', 'post')) %>%
  # mutate(phase = factor(phase, levels = c('pre', 'post'))))
summary(mod1)
```

```{r}
empirical.across <- compute_across_similarity(M_mat, 'empirical',nboot = 1000)
baselines.across <- map_dfr(seq_len(num_permutations), ~M_mat %>%
  group_by(target, gameID) %>%
  mutate(repetition = sample(repetition, size = length(repetition))) %>% # shuffle within repetition 
  ungroup() %>%
  compute_across_similarity(.x)) # this passes in the iteration number

baselines.across %>% 
  group_by(repetition) %>% 
  summarize(`ci_upper`=quantile(empirical_stat, probs=0.975),
            `ci_lower`=quantile(empirical_stat, probs=0.025),
            `empirical_stat`=quantile(empirical_stat, probs=0.5)) %>%
  mutate(sample_id = 'baseline') %>%
  rbind(empirical.across %>% select(-n, -mean)) %>%
ggplot(aes(x = repetition, y = empirical_stat, group = sample_id,
           fill = sample_id == 'empirical', color = sample_id == 'empirical')) +
  geom_line() +
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.5, color = NA ) + #data = empirical, 
  #ylim(0,.2) +
  ylab('across-game similarity') +
  theme_few()

```

## Temporal structure 

```{r}


```
